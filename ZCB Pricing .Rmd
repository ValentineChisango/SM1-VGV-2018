---
title: "ZCB Pricing"
author:
- Valentine Chisango
- George Parekkadavil
- Vegan Pather
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls(all =TRUE))
```

```{r 1}
# Closed form solution of the Bond price

bond_price <- function(alpha=0.08,beta=0.8,sigma=0.005,t=0,T=5,r=0.08){
  # alpha, beta, sigma <- Fixed Parameters
  # T <- maturity time
  # r <- Initial rate at time 0  
  A <- (1-exp(-beta*(T-t)))/(beta)
  B <- (1/beta)*((alpha-(sigma)^2/(2*beta))*(A - T +t) - (sigma^(2)*A^2)/(4))
  exp(-A*r +B)
}

```

```{r 2}

# Crude Monte Carlo function 

Crude_Monte_Carlo=function(alpha =0.08,beta=0.8,sigma=0.005,T=5,r = 0.08,n=1000,s=100){
  
  # alpha, beta, sigma <- Fixed Parameters
  # T <- maturity time
  # r <- Initial rate at time 0
  # n <- Number of Simulations
  # s <- NUmber of Sub-intervals over time 
  
  #Simulate interest rates
  dt <- T/s # Length of sub-intervals
  sim_path = matrix(0,s+1,n) # Matrix that stores rate pathways
  sim_path[1,]= r # Initial rates on first row.
  
  for (i in 1:n){
    for (j in 2:(s+1)){
      dr=(alpha-beta*sim_path[j-1,i])*dt+sigma*sqrt(dt)*rnorm(1)# Discretize the SDE of the interest model using Euler Discretization to simulate rates over discrete sub-intervals
      sim_path[j,i]=sim_path[j-1,i]+dr
    }
  }
  
  # Monte Carlo Simulations
  Sum = colSums(sim_path[2:(s+1),]*dt) # Approximate the integral using summation
  int = exp(-Sum) # Take the exponent of the Integral
  mean = mean(int) # Find the average of expression
  mean
  
}


```

```{r 3}
# Improvements to the Monte Carlo Simulation

# Antithetic Variates

Antithetic_variates = function(alpha =0.08,beta=0.8,sigma=0.005,T=5,r = 0.08,n=1000,s=100){

  # alpha, beta, sigma <- Fixed Parameters
  # T <- maturity time
  # r <- Initial rate at time 0
  # n <- Number of Simulations
  # s <- NUmber of Sub-intervals over time   
  
  dt <- T/s # Length of sub-intervals
  sim_path= matrix(0,s+1,n) # Matrix that stores rate pathways
  sim_path_inv= matrix(0,nrow = s+1, ncol = n)# matrix to generate interest paths using negative values of RV
  sim_path[1,] = r
  sim_path_inv[1,] = r
  z = rnorm(n) # Generate standard normal values
  z. = -z # Negative RV
  
  for (i in 1:n){
    for (j in 2:(s+1)){
      dr = (alpha-beta*sim_path[j-1,i])*dt+sigma*sqrt(dt)*z[i] # Same Euler Discretization as in the Crude Monte Carlo function
      dr_i = (alpha-beta*sim_path_inv[j-1,i])*dt + sigma*sqrt(dt)*z.[i] # Euler Discretization for negative rates
      sim_path[j,i] =sim_path[j-1,i]+dr
      sim_path_inv[j,i] = sim_path_inv[j-1,i]+dr_i
      
    }
  }
  
  # Monte Carlo Simulations
  Sum = colSums(sim_path[2:(s+1),]*dt) # The Sum and Sum. variables record the summation of their respective rates to approximate the integral
  Sum.= colSums(sim_path_inv[2:(s+1),]*dt)
  int = exp(-Sum.) #Exponential of the estimate
  int.= exp(-Sum) #Exponential of the estimate under the negative rv 
  mean_1 = mean(int) # Estimate using Z_i
  mean_2 = mean(int.)  # Estimate using -Z_i
  result = (mean_1+mean_2)/2 # Final estimate
  result
  
}


```

```{r 4}

# Moment matching

Moment_Matching = function(alpha = 0.08, beta = 0.8, sigma = 0.005, T = 5,r = 0.08, n = 1000, s = 200){
  
  # alpha, beta, sigma <- Fixed Parameters
  # T <- maturity time
  # r0 <- Initial rate at time 0
  # n <- Number of Simulations
  # s <- NUmber of Subintervals 
  
  #Simulate interest rates
  dt <- T/s # Length of sub-intervals
  sim_path= matrix(0,s+1,n) # Matrix that stores rate pathways
  sim_path[1,]= r
  z=rnorm(n)
  z_m= z-mean(z) # Moment matching transformation of RV to match finite moments 
  
  for (i in 1:n){
    for (j in 2:(s+1)){
      dr=(alpha-beta*sim_path[j-1,i])*dt+sigma*sqrt(dt)*z_m[i] # Simulate rates using the transformed rv 
      sim_path[j,i]=sim_path[j-1,i]+dr
    }
  }
  
  Sum=colSums(sim_path[2:(s+1),]*dt)
  int=exp(-Sum)
  result=mean(int)
  result

}

```

```{r 5}

# Control Variates

# We have decided to make use of the CIR model as our control variate process.
# Below is the closed form solution under the CIR model
bond_price_CIR <- function(alpha =0.08,beta=0.8,sigma=0.005,t=0,T=5,r = 0.08){
  h <- sqrt(beta^(2)+2*sigma^(2))
  A <-(2*h*exp((beta+h)*(T-t)/2)/(2*h+(beta+h)*(exp((T-t)*(h))-1)))^((2*alpha)/sigma^(2))
  B <-2*(exp((T-t)*(h))-1)/(2*h+(beta+h)*(exp((T-t)*(h))-1))
  A*exp(-B*r)
}


# Monte Carlo Simulations of Bond Price under the CIR model

CIR_MC= function(alpha =0.08,beta=0.8,sigma=0.005,T=5,r = 0.08,n=1000,s=100){
  
  dt <- T/s # Length of sub-intervals
  sim_path= matrix(0,s+1,n) # Matrix that stores rate pathways
  sim_path[1,]= r
  
  for (i in 1:n){
    for (j in 2:(s+1)){
      dr=(alpha-beta*sim_path[j-1,i])*dt+(sigma*sqrt(dt)*rnorm(1)*sqrt(sim_path[j-1,i]))# Euler Discretization
      sim_path[j,i]=sim_path[j-1,i]+dr
    
    }
  }
  
  # Monte Carlo Simulations
  Sum=colSums(sim_path[2:(s+1),]*dt)
  int=exp(-Sum)
  result=mean(int)
  result
  
}
# Therefore the control variates estimate:

Control_Variates_estimate= function(alpha =0.08,beta=0.8,sigma=0.005,t=0,T=5,r = 0.08,n=1000,s=100){
  Crude_Monte_Carlo(alpha,beta,sigma,T,r,n,s)[1]- CIR_MC(alpha,beta,sigma,T,r,n,s)[1]+bond_price_CIR(alpha,beta,sigma,t,T,r)
}



```

```{r 6}
# Explicit Method

explicit = function(alpha = 0.08,beta = 0.8, sigma = 0.005,r = 0.08, I = 1:1250, J = seq(-0.4,0.6,0.005),T = 5){
  
  # I = partition of time interval
  # J = partition of short rates sequence
  
  M <- length(J) # Number of short rate grid points
  N <- length(I) # Number of time grid poiints
  
  
  dt <- T/N # Lenght of each time subinterval
  dr <- J[2] -J[1] # Lenght of each time interval
  
  # For each j in J we define the following functions at a fixed time point
  
  pd <- function(j){
    ((J[j]+1/dt)^(-1))*(sigma^2/(2*(dr^2)) -(alpha -beta*J[j])/(2*dr))
  }
  
  
  pm <- function(j){
    ((J[j]+1/dt)^(-1))*(1/dt -sigma^2/(dr^2))
  }
  
  
  pu <- function(j){
    ((J[j]+1/dt)^(-1))*(sigma^2/(2*(dr^2)) + (alpha -beta*J[j])/(2*dr))
  }

  #Setting up tridiagonal matrix
  
  Diag_1 <- matrix(0,ncol = M, nrow = M)
  
  # Filling main diagonal of matrix 
  for (j in 1:M){
    Diag_1[j,j] <- pm(j)
    
  }
  
  # Filling lower diagonal of matrix 
  for (j in 2:M){
    Diag_1[j,j-1] <- pd(j)
  }
  
  # Filling upper diagonal of matirx 
  for (j in 1:(M-1)){
    Diag_1[j,j+1] <- pu(j)
  }  
  
  # Bond price values at maturity are all 1 unit   
  Bond_values <- matrix(1,nrow=M, ncol =1)
  
  # Working backwards in time
  for (i in 1:(length(I)+1)){
    C <- matrix(0,ncol = 1, nrow = M) # Another matrix for boundary conditions
    C[M,1] <- (pu(M))*Bond_values[M,1]
    C[1,1] <- pd(1)*Bond_values[1,1]
    
    Bond_values <- Diag_1%*%Bond_values
    Bond_values <- Bond_values
  }
  
  # Finding index of the desired short rate
  index = match(as.character(r),J)
  # Output is the corresponding bond price at time 0
  Bond_values[index]
}



```

```{r 7}
# Implicit Method

implicit <- function(alpha = 0.08,beta = 0.8,sigma = 0.005,r = 0.08,I = 1:1250, J =seq(-0.4,0.6,0.005),T=5){
  
  # I = partition of time interval
  # J = partition of short rate variable
  
  M <- length(J) # Number of short rate grid points
  N <- length(I) # Number of time grid poiint
  
  dr <- J[2] - J[1] # length of each sub-interval across J
  dt <- T/N # length of each sub-interval across I
  
  # For each j in J we define the following functions at a fixed time point
  
  pd <- function(j){
    dt*((alpha-beta*J[j])/(2*dr) - (sigma^2)/(2*dr^2))
    
  }
  
  pm <- function(j){
    dt*(J[j] + 1/dt +sigma^2/(dr^2))
  }
  
  pu <- function(j){
    -dt*((alpha-beta*J[j])/(2*dr) + (sigma^2)/(2*dr^2))
  }
  
  # Setting up tridiagonal matrix
  Diag <- matrix(0,nrow = M,ncol = M)
  
  # Filling main diagonal
  for (j in 1:M){
    Diag[j,j] <- pm(j)
    
  }
  
  # Filling lower diagonal
  for (j in 2:M){
    Diag[j,j-1] <- pd(j)
  }
  
  # Filling upper diagonal
  for (j in 1:(M-1)){
    Diag[j,j+1] <- pu(j)
  }
  
  
  Bond_values <- matrix(1,ncol = 1,nrow = M) # The matrix of bond prices at maturity time 
  Inv <- solve(Diag) # Inverse of tridiagonal matrix
  
  for (i in 1:(length(I) +1)){
    C <- matrix(0,ncol = 1, nrow = M) # Another matrix for boundary conditions
    C[M,1] <- (-pu(M))*Bond_values[M,1]
    C[1,1] <- -pd(1)*Bond_values[1,1]

    RHS <- Bond_values + C # Working backwards recursively 
    Bond_values <- Inv%*%RHS
  }

  # Finding index of the desired short rate
  index = match(as.character(r),J)
  # Output is the corresponding bond price at time 0
  Bond_values[index]
}

```

```{r 8}
# Crank-Nicholson Method

CN <- function(alpha = 0.08, beta = 0.8, sigma = 0.005, r = 0.08, T = 5 , I = 1:1250, J = seq(-0.4,0.6,0.005)){
  
  # I = partition of time interval
  # J = partition of short rate interval
  
  M <- length(J) # Number of short rate grid points
  N <- length(I) # Number of time grid poiints
  
  dt <- T/N # Length of each time subinterval
  dr <- J[2] -J[1] # Lenght of each rate subinterval
  
  #========================================================================================
  # Define the following functions for j = 1,...,M at each time point i
  
  pd <- function(j){
    (alpha -beta*J[j])/(4*dr) - sigma^2/(4*(dr^2))
  }
  
  pm <- function(j){
    sigma^2/(2*(dr^2)) + J[j]/2
  }
  
  pu <- function(j){
    -(alpha -beta*J[j])/(4*dr) - sigma^2/(4*(dr^2)) 
  }
  
  #========================================================================================
  # Define 2 tridiagonal matricies. One for time point i and one for time point i+1
  
  Diag_1 <- matrix(0,nrow = M,ncol = M)
  Diag_2 <- matrix(0,nrow = M,ncol = M)
  
  # Filling main diagonal of matrix 1
  for (j in 1:M){
    Diag_1[j,j] <- -1/dt - pm(j)
  }
  
  # Filling lower diagonal of matrix 1
  for (j in 2:M){
    Diag_1[j,j-1] <- -pd(j)
  }
  
  # Filling upper diagonal of matirx 1
  for (j in 1:M-1){
    Diag_1[j,j+1] <- -pu(j)
  }  
  
  
  # Filling main diagonal of matrix 2
  for (j in 1:M){
    Diag_2[j,j] <- -1/dt + pm(j)
    }
  
  # Filling lower diagonal of matrix 2
  for (j in 2:M){
    Diag_2[j,j-1] <- pd(j)
    }
  
  # Filling upper diagonal of matirx 2
  for (j in 1:M-1){
    Diag_2[j,j+1] <- pu(j)
  }
  
  
  #========================================================================================
  # Constructing more matricies and iterating the procedure from maturity to time 0

  Bond_values <- matrix(1,nrow = M, ncol = 1)
  
 

  # C_2 <- matrix(0,nrow = M,ncol = 1)
  # C_2[1,1] <- pd(1)
  # C_2[M,1] <- pu(M)
  Inv <- solve(Diag_1)
  
  for (i in 1:(length(I)+1)){
    C_1 <- matrix(0,nrow = M,ncol = 1)
    C_1[1,1] <- pd(1)*Bond_values[1,1]
    C_1[M,1] <- pu(M)*Bond_values[M,1]
    RHS <- Diag_2%*%Bond_values +2*C_1
    Bond_values <- Inv%*%RHS
  }

  # Index of rate corresponding to desired short rate
  index = match(as.character(r), J)
  # Output corresponding to desired short rate
  Bond_values[index]
}

```


```{r 9}
# Plots of the different methods
par(mfrow = c(2,2))

xvec <- seq(-0.4,0.6,0.005) # Vector for rates

known_sol <- NULL # Vector to hold the known closed form solution
for (r in 1:length(xvec)){
  known_sol[r] <- bond_price(0.08,0.8,0.005,0,5,xvec[r])
}

CR <- NULL # Vector to hold Crude Monte Carlo Solutions
AV <- NULL # Vector to hold Antithetic Monte Carlo Solutions
MM <- NULL # Vector to hold Moment Matching  Carlo Solutions
CV <- NULL # Vector to hold Control Variates Monte Carlo Solutions

Expl <- NULL # Vector to hold Explicit method Solutions
Impl <- NULL # Vector to hold Implicit method Solutions
Crank <- NULL # Vector to hold Crank-Nicolson Solutions


# Plots of Monte Carlo Methods ----------------------------------------------------------------------

for (i in 1: length(xvec)){
  CR[i] <- Crude_Monte_Carlo(r = xvec[i])
}

for (i in 1: length(xvec)){
  AV[i] <- Antithetic_variates(r = xvec[i])
}

for (i in 1: length(xvec)){
  MM[i] <- Moment_Matching(r = xvec[i])
}

for (i in 1: length(xvec)){
  CV[i] <- Control_Variates_estimate(r = xvec[i])
}

plot(CR, x = xvec[1:length(xvec)],xlab = " Annual Interest Rate",ylab = "Bond Price",type = "l", col ="red", main = "Monte Carlo Solutions vs Known Solution")
lines(xvec, known_sol, col ="blue", lty =1.5)
lines(xvec, AV, col ="black", lty =1.5)
lines(xvec, MM, col ="yellow", lty =1.5)
lines(xvec, CV, col ="green", lty =1.5)


# Plots of Finite Difference Methods ----------------------------------------------------------------------

for (i in 1: length(xvec)){
  Expl[i] <- explicit(r = xvec[i], I = 1:10000)
}

for (i in 1: length(xvec)){
  Impl[i] <- implicit(r = xvec[i])
}

for (i in 1: length(xvec)){
  Crank[i] <- CN(r = xvec[i])
}


plot(Expl, x = xvec ,xlab = " Annual Interest Rate",ylab = "Bond Price",type = "l", col ="red", main = "Explicit Method vs Known Solution")
lines(xvec, known_sol, col ="blue", lty =1.5)

plot(Impl, x = xvec ,xlab = " Annual Interest Rate",ylab = "Bond Price",type = "l", col ="red", main = "Implicit Method vs Known Solution")
lines(xvec, known_sol, col ="blue", lty =1.5)


plot(Crank, x = xvec ,xlab = " Annual Interest Rate",ylab = "Bond Price",type = "l", col ="red", main = "Crank-Nicolson Method vs Known Solution")
lines(xvec, known_sol, col ="blue", lty =1.5)

```

```{r 10, echo = FALSE}
# Comparison of results for numerical methods


compare_mat <- matrix(NA,nrow = 7, ncol = 4) # matrix of comparison

colnames(compare_mat) <- c("Price", "Known Price", "Error", "System Time")
rownames(compare_mat) <- c("Crude Monte Carlo", "Antithetic Variates", "Moment Matching", "Control Variates", "Explicit Method", "Implicit Method", "Crank-Nicolson Method")

compare_mat[,2] <- bond_price()

# Crude Monte Carlo
start_time <- proc.time()[1]
compare_mat[1,1] <- Crude_Monte_Carlo()
compare_mat[1,4] <- proc.time()[1] - start_time
compare_mat[1,3] <- compare_mat[1,2] - compare_mat[1,1]

# Antithetic Variates
start_time <- proc.time()[1]
compare_mat[2,1] <- Antithetic_variates()
compare_mat[2,4] <- proc.time()[1] - start_time
compare_mat[2,3] <- compare_mat[2,2] - compare_mat[2,1]

# Moment Matching
start_time <- proc.time()[1]
compare_mat[3,1] <- Moment_Matching()
compare_mat[3,4] <- proc.time()[1] - start_time
compare_mat[3,3] <- compare_mat[3,2] - compare_mat[3,1]

# Control Variates
start_time <- proc.time()[1]
compare_mat[4,1] <- Control_Variates_estimate()
compare_mat[4,4] <- proc.time()[1] - start_time
compare_mat[4,3] <- compare_mat[4,2] - compare_mat[4,1]

# Explicit method
start_time <- proc.time()[1]
compare_mat[5,1] <- explicit()
compare_mat[5,4] <- proc.time()[1] - start_time
compare_mat[5,3] <- compare_mat[5,2] - compare_mat[5,1]

# Implicit method
start_time <- proc.time()[1]
compare_mat[6,1] <- implicit()
compare_mat[6,4] <- proc.time()[1] - start_time
compare_mat[6,3] <- compare_mat[6,2] - compare_mat[6,1]

# Crank-Nicolson method
start_time <- proc.time()[1]
compare_mat[7,1] <- CN()
compare_mat[7,4] <- proc.time()[1] - start_time
compare_mat[7,3] <- compare_mat[7,2] - compare_mat[7,1]

library(xtable)
xtable(compare_mat, digits = 5)
       
```

```{r 11}
# Sensitivity Tests

senses <- matrix(nrow=13, ncol=9) # matrix to hold prices for various parameters
colnames(senses) <-c("Parameters","Closed Form","Crude Monte Carlo","Antithetic Variates","Moment Matching","Control Variates","Explicit","Implicit","Crank-Nicholson")
#xvec=c(Closed Form,Crude Monte Carlo,Antithetic Variates,Moment Matching,Control Variates,Explicit,Implicit,Crank Nicholson) #list of numerical methods

#Initial Parameters
senses[1,2]=bond_price()
senses[1,3]=Crude_Monte_Carlo()
senses[1,4]=Antithetic_variates()
senses[1,5]=Moment_Matching()
senses[1,6]=Control_Variates_estimate()
senses[1,7]=explicit()
senses[1,8]=implicit()
senses[1,9]=CN()

#r=0.05
senses[2,2]=bond_price(r=0.05)
senses[2,3]=Crude_Monte_Carlo(r=0.05)
senses[2,4]=Antithetic_variates(r=0.05)
senses[2,5]=Moment_Matching(r=0.05)
senses[2,6]=Control_Variates_estimate(r=0.05)
senses[2,7]=explicit(r=0.05)
senses[2,8]=implicit(r=0.05)
senses[2,9]=CN(r=0.05)

#r=0.1
senses[3,2]=bond_price(r=0.1)
senses[3,3]=Crude_Monte_Carlo(r=0.1)
senses[3,4]=Antithetic_variates(r=0.1)
senses[3,5]=Moment_Matching(r=0.1)
senses[3,6]=Control_Variates_estimate(r=0.1)
senses[3,7]=explicit(r=0.1)
senses[3,8]=implicit(r=0.1)
senses[3,9]=CN(r=0.1)

#T=1
senses[4,2]=bond_price(T=1)
senses[4,3]=Crude_Monte_Carlo(T=1)
senses[4,4]=Antithetic_variates(T=1)
senses[4,5]=Moment_Matching(T=1)
senses[4,6]=Control_Variates_estimate(T=1)
senses[4,7]=explicit(T=1)
senses[4,8]=implicit(T=1)
senses[4,9]=CN(T=1)

#T=10
senses[5,2]=bond_price(T=10)
senses[5,3]=Crude_Monte_Carlo(T=10)
senses[5,4]=Antithetic_variates(T=10)
senses[5,5]=Moment_Matching(T=10)
senses[5,6]=Control_Variates_estimate(T=10)
senses[5,7]=explicit(T=10)
senses[5,8]=implicit(T=10)
senses[5,9]=CN(T=10)

#sigma=0.001
senses[6,2]=bond_price(sigma=0.001)
senses[6,3]=Crude_Monte_Carlo(sigma=0.001)
senses[6,4]=Antithetic_variates(sigma=0.001)
senses[6,5]=Moment_Matching(sigma=0.001)
senses[6,6]=Control_Variates_estimate(sigma=0.001)
senses[6,7]=explicit(sigma=0.001)
senses[6,8]=implicit(sigma=0.001)
senses[6,9]=CN(sigma=0.001)


#sigma=0.01
senses[7,2]=bond_price(sigma=0.01)
senses[7,3]=Crude_Monte_Carlo(sigma=0.01)
senses[7,4]=Antithetic_variates(sigma=0.01)
senses[7,5]=Moment_Matching(sigma=0.01)
senses[7,6]=Control_Variates_estimate(sigma=0.01)
senses[7,7]=explicit(sigma=0.01)
senses[7,8]=implicit(sigma=0.01)
senses[7,9]=CN(sigma=0.01)


#alpha=0.01
senses[8,2]=bond_price(alpha=0.01)
senses[8,3]=Crude_Monte_Carlo(alpha=0.01)
senses[8,4]=Antithetic_variates(alpha=0.01)
senses[8,5]=Moment_Matching(alpha=0.01)
senses[8,6]=Control_Variates_estimate(alpha=0.01)
senses[8,7]=explicit(alpha=0.01)
senses[8,8]=implicit(alpha=0.01)
senses[8,9]=CN(alpha=0.01)

#alpha=0.16
senses[9,2]=bond_price(alpha=0.16)
senses[9,3]=Crude_Monte_Carlo(alpha=0.16)
senses[9,4]=Antithetic_variates(alpha=0.16)
senses[9,5]=Moment_Matching(alpha=0.16)
senses[9,6]=Control_Variates_estimate(alpha=0.16)
senses[9,7]=explicit(alpha=0.16)
senses[9,8]=implicit(alpha=0.16)
senses[9,9]=CN(alpha=0.16)

#beta=0.1
senses[10,2]=bond_price(beta=0.1)
senses[10,3]=Crude_Monte_Carlo(beta=0.1)
senses[10,4]=Antithetic_variates(beta=0.1)
senses[10,5]=Moment_Matching(beta=0.1)
senses[10,6]=Control_Variates_estimate(beta=0.1)
senses[10,7]=explicit(beta=0.1)
senses[10,8]=implicit(beta=0.1)
senses[10,9]=CN(beta=0.1)

#beta=1.6
senses[11,2]=bond_price(beta=1.6)
senses[11,3]=Crude_Monte_Carlo(beta=1.6)
senses[11,4]=Antithetic_variates(beta=1.6)
senses[11,5]=Moment_Matching(beta=1.6)
senses[11,6]=Control_Variates_estimate(beta=1.6)
senses[11,7]=explicit(beta=1.6)
senses[11,8]=implicit(beta=1.6)
senses[11,9]=CN(beta=1.6)

#alpha=0.01,beta=0.1
senses[12,2]=bond_price(alpha=0.01,beta=0.1)
senses[12,3]=Crude_Monte_Carlo(alpha=0.01,beta=0.1)
senses[12,4]=Antithetic_variates(alpha=0.01,beta=0.1)
senses[12,5]=Moment_Matching(alpha=0.01,beta=0.1)
senses[12,6]=Control_Variates_estimate(alpha=0.01,beta=0.1)
senses[12,7]=explicit(alpha=0.01,beta=0.1)
senses[12,8]=implicit(alpha=0.01,beta=0.1)
senses[12,9]=CN(alpha=0.01,beta=0.1)

#alpha=0.16,beta=1.6
senses[13,2]=bond_price(alpha=0.16,beta=1.6)
senses[13,3]=Crude_Monte_Carlo(alpha=0.16,beta=1.6)
senses[13,4]=Antithetic_variates(alpha=0.16,beta=1.6)
senses[13,5]=Moment_Matching(alpha=0.16,beta=1.6)
senses[13,6]=Control_Variates_estimate(alpha=0.16,beta=1.6)
senses[13,7]=explicit(alpha=0.16,beta=1.6)
senses[13,8]=implicit(alpha=0.16,beta=1.6)
senses[13,9]=CN(alpha=0.16,beta=1.6)

par(mfrow=c(1,1))
plot(x=1:8,y=senses[1,2:9], ylim =c(0.58,0.66), xlab = "Numerical Method", ylab = "Bond Price", main = "Sensitivity Test: Interest Rate")
#axis(1, at=1:8, labels=xvec)
lines(1:8, senses[2,2:9], col="red",type = "p")
lines(1:8, senses[3,2:9],col ="blue",type = "p")
legend("bottomright", inset = c(-0,0), legend = c("r=0.05", "r=0.08", "r=0.1"), lty = c(1,1,1), col = c("red","black","blue", "red"), cex = 0.8, bty ="n")

plot(x=1:8,y=senses[1,2:9], ylim =c(0,2.2), xlab = "Numerical Method", ylab = "Bond Price", main = "Sensitivity Test: Time to maturity")
#axis(1, at=1:8, labels=xvec)
lines(1:8, senses[4,2:9], col="red",type = "p")
lines(1:8, senses[5,2:9],col ="blue",type = "p")
legend("topright", inset = c(-0,0), legend = c("T=1", "T=5", "T=10"), lty = c(1,1,1), col = c("red","black","blue", "red"), cex = 0.8, bty ="n")

plot(x=1:8,y=senses[1,2:9], ylim =c(0,2.2), xlab = "Numerical Method", ylab = "Bond Price", main = "Sensitivity Test: Sigma")
#axis(1, at=1:8, labels=xvec)
lines(1:8, senses[6,2:9], col="red",type = "p")
lines(1:8, senses[7,2:9],col ="blue",type = "p")
legend("bottomright", inset = c(-0,0), legend = c("sigma=0.001", "sigma=0.005", "sigma=0.1"), lty = c(1,1,1), col = c("red","black","blue", "red"), cex = 0.8, bty ="n")

plot(x=1:8,y=senses[1,2:9], ylim =c(0,2.2), xlab = "Numerical Method", ylab = "Bond Price", main = "Sensitivity Test: Alpha")
#axis(1, at=1:8, labels=xvec)
lines(1:8, senses[8,2:9], col="red",type = "p")
lines(1:8, senses[9,2:9],col ="blue",type = "p")
legend("bottomright", inset = c(-0,0), legend = c("alpha=0.01", "alpha=0.08", "alpha=0.16"), lty = c(1,1,1), col = c("red","black","blue", "red"), cex = 0.8, bty ="n")

plot(x=1:8,y=senses[1,2:9], ylim =c(0,2.2), xlab = "Numerical Method", ylab = "Bond Price", main = "Sensitivity Test: Beta")
#axis(1, at=1:8, labels=xvec)
lines(1:8, senses[10,2:9], col="red",type = "p")
lines(1:8, senses[11,2:9],col ="blue",type = "p")
legend("topright", inset = c(-0,0), legend = c("beta=0.1", "beta=0.8", "beta=1.6"), lty = c(1,1,1), col = c("red","black","blue", "red"), cex = 0.8, bty ="n")

plot(x=1:8,y=senses[1,2:9], ylim =c(0,2.2), xlab = "Numerical Method", ylab = "Bond Price", main = "Sensitivity Test: Alpha & Beta")
#axis(1, at=1:8, labels=xvec)
lines(1:8, senses[12,2:9], col="red",type = "p")
lines(1:8, senses[13,2:9],col ="blue",type = "p")
legend("topright", inset = c(-0,0), legend = c("alpha=0.01,beta=0.1", "alpha=0.08,beta=0.8", "alpha=0.16,beta=1.6"), lty = c(1,1,1), col = c("red","black","blue", "red"), cex = 0.8, bty ="n")
```

```{r 12}
#Stability Tests

# We do this by checking the variance amongst the results when simulated many times.

CR = NULL
AN = NULL
MM = NULL
CV = NULL

for ( i in 1:100){
  CR[i]=Crude_Monte_Carlo()
  #AN[i]=Antithetic_variates()
  #MM[i]=Moment_Matching()
  CV[i]=Control_Variates_estimate()
}

```


```{r 13}
# Convergence Tests for finite difference methods
# Varying time steps

time_vec <- seq(0,100,1)

closed <- NULL
CN_conv <- NULL
Impl_conv <- NULL
Expl_conv <- NULL

for (i in 1:length(time_vec)){
  closed[i] <- bond_price()
}

for (i in 1:length(time_vec)){
  CN_conv[i] <- CN(I = 1:time_vec[i])
}

for (i in 1:length(time_vec)){
  Impl_conv[i] <- implicit(I = 1:time_vec[i])
}

for (i in 1:length(time_vec)){
  Expl_conv[i] <- explicit(I = 1:time_vec[i])
}

par(mfrow = c(1,1))
plot(closed, x = time_vec, type = "l", ylim = c(0.53,0.65), xlab = "Number of time steps", ylab = "Estimated Price" , lty =1, font.main = 1, main = "Finite Difference Bond Prices as Time Steps Increase")
lines(x = time_vec, y = CN_conv, type = "l", lty = 2, lwd =1.5)
lines(x = time_vec, y = Impl_conv, type = "l", lty = 2, col = "blue",lwd =1.5)
lines(x = time_vec, y = Expl_conv, type = "l", lty = 2, col = "red",lwd =1.5)
legend(x = 60, y = 0.6, legend = c("Closed Form", "Crank-Nicolson", "Implicit", "Explicit"), lty = c(1,2,2,2), col = c("black","black","blue", "red"), cex = 0.8, bty ="n")

```




```{r 14}
# Convergence Tests for finite difference methods
# Varying rate steps

# rate_step <- c(0.02,0.016,0.012,0.010,0.008,0.006,0.005,0.004,0.003,0.002)
# rate_vec <- NULL
# for (i in 1:length(rate_step)){
#   rate_vec[i] <- length(seq(-0.4,0.6,rate_step[i])) 
# }
# 
# 
# closed_r <- NULL
# CN_conv_1 <- NULL
# Impl_conv_1 <- NULL
# Expl_conv_1 <- NULL
# 
# 
# 
# for (i in 1:length(rate_step)){
#   closed_r[i] <- bond_price()
# }
# 
# for (i in 1:length(rate_step)){
#   CN_conv_1[i] <- CN(J = seq(-0.4,0.6,rate_step[i]))
# }
# 
# for (i in 1:length(rate_step)){
#   Impl_conv_1[i] <- implicit(J = seq(-0.4,0.6,rate_step[i]))
# }
# 
# for (i in 1:length(rate_step)){
#   Expl_conv_1[i] <- explicit(J = seq(-0.4,0.6,rate_step[i]))
# }
# 
# par(mfrow = c(1,1))
# plot(closed_r, x = rate_vec, type = "l", xlab = "Number of time steps", ylab = "Estimated Price")
# lines(x = rate_vec, y = CN_conv_1, type = "l", lty = 2)
# lines(x = rate_vec, y = Impl_conv_1, type = "l", lty = 3, col = "blue")
# lines(x = rate_vec, y = Expl_conv_1, type = "l", lty = 4, col = "red")
# legend(x = 60, y = 0.6, legend = c("Closed Form", "Crank-Nicolson", "Implicit", "Explicit"), lty = 1:4, col = c("black","black","blue", "red"), cex = 0.8)

```


```{r 15}
# Covergence tests for Monte Carlo functions

trials_vec <- seq(10,2000,50)

closed_1 <- NULL
CR_conv <- NULL
AV_conv <- NULL
MM_conv <- NULL
CV_conv <- NULL

for (i in 1:length(trials_vec)){
  closed_1[i] <- bond_price()
}

for (i in 1:length(trials_vec)){
  CR_conv[i] <- Crude_Monte_Carlo(n = trials_vec[i])
}

for (i in 1:length(trials_vec)){
  AV_conv[i] <- Antithetic_variates(n = trials_vec[i])
}

for (i in 1:length(trials_vec)){
  MM_conv[i] <- Moment_Matching(n = trials_vec[i])
}

for (i in 1:length(trials_vec)){
  CV_conv[i] <- Control_Variates_estimate(n = trials_vec[i])
}

plot(closed_1, x = trials_vec, type = "l",ylim = c(0.61,0.63), xlab = "Number of Trials", ylab = "Estimated Price", lty = 2, lwd = 2,font.main = 1, main = "Monte Carlo Bond Prices over Number of Trials")
lines(x = trials_vec, y = CR_conv, type = "l", lty = 1, lwd =1.5)
lines(x = trials_vec, y = AV_conv, type = "l", lty = 1, col = "blue", lwd =1.5)
lines(x = trials_vec, y = MM_conv, type = "l", lty = 1, col = "green", lwd =1.5)
lines(x = trials_vec, y = CV_conv, type = "l", lty = 1, col = "red", lwd = 2)

legend(x = 600, y = 0.62, legend = c("Closed Form", "Crude Monte Carlo", "Antithetic Variates"), lty = c(2,1,1), lwd =c(1.5,1.5,1.5),col = c("black","black","blue"), cex = 0.8, bty="n")

legend(x = 1200, y = 0.62, legend = c("Moment Matching","Control Variates"), lty = c(1,1), lwd =c(1.5,1.5),col = c("green","red"), cex = 0.8, bty="n")

```



