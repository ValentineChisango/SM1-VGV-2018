---
title: "ZCB Pricing"
author:
- Valentine Chisango
- George Parekkadavil
- Vegan Pather
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls(all =TRUE))
```

```{r 1}
# Closed form solution to Bond price

bond_price <- function(alpha,beta,sigma,t,T,r){
  A <- (beta*(1-exp(-beta*(T-t))))/(alpha)
  B <- (1/beta)*((alpha-(sigma)^2/(2*beta))*(A - T +t) - (sigma^(2)*A^2)/(4))
  exp(-A*r +B)
}

```

```{r 2}
# Monte Carlo Simulation

monte_carlo <- function(alpha, beta, sigma, t, T, r, n, s){
  # s = number of sub-intervals
  # n = number of simulation trials  
  
  dt <- T/s
  sim_path <- matrix(NA,nrow = n, ncol = 1) # matrix to store simulated path integrals
  sim_r <- NULL # vector to store rates on the path
  
  
  for (d in 1:n){
    sim_r[1] <- r
    for (j in 2:s){
      mu <- alpha/beta + exp(-beta*dt)*(sim_r[j-1] -alpha/beta)
      sd <- sqrt((sigma^2/(2*beta))*(1 -exp(-2*beta*(dt))))
      sim_r[j] <- rnorm(1,mu,sd)
    }
    
    int <- dt*(sum(sim_r)) # integral of path
    sim_path[d,1] <- exp(-int) # bond price of path
    
  }
  mean(sim_path) # empirical expectation of bond price using all paths
}

```

```{r 3}
# Improvements to the Monte Carlo Simulation
# Antithetic Variates

```

```{r 4}
# Explicit Method

# Simple Bond price function
B <- function(t,r){
  exp(-(T-t)*r)
}

explicit <- function(alpha,beta,sigma,r,I,dr){

# I = partition of time
# dr = length of rate sub-intervals
# r must be in the middle of partition of J
# length of J must be twice the length of I

J <- seq(0,2*r,dr)    

dt = 1/length(I) # length of each time sub-interval
dr = J[2] -J[1] # length of each rate sub-interval


V <- matrix(NA, nrow = length(J), ncol = length(I)+1) # empty matrix
nr <- length(J) # number of rows of the matrix - represents partition of rate
nt <- length(I)+1 # number of columns - represents partition of time

V[,length(I)+1] <- rep(1) # Boundary condition at expiry of bond

count <- 0 # set up count variable
for (i in rev(I)){ # rev is the reverse order of the time partition
  count <- count+1 # keeping track of loop
  for (j in (1+count):(nr-count)){
    pu <- sigma^2/(2*dr^2) + (alpha -beta*J[nr-j])/(2*dr) # up value
    pm <- 1/dt -sigma^2/(dr^2) # middle value
    pd <- sigma^2/(2*(dr^2)) - (alpha -beta*J[nr-j])/(2*dr) # down value
    V[j,i] <- (1/(J[nr-j]+1/dt))*(pu*V[j-1,i+1] + pm*V[j,i+1] +pd*V[j+1,i+1])
  }

}

V[(nr+1)/2,1]
}

explicit(0.01,0.1,0.04,0.10,1:20,0.005)


```

```{r 5}
# Implicit Method
```

```{r 6}
# Crank-Nicholson Method
```

```{r 7}
# Modified Fully Implicit Method
```

```{r 8, echo = FALSE}
# Comparison of results
# Varying short rates

compare_mat <- matrix(NA,nrow = 10, ncol = 8) # matrix of comparison

colnames(compare_mat) <- c("Alpha","Beta","Sigma","Initial rate","Known Price","Monte Carlo"," MC System Time","MC Squared Deviations")


a = 0.01
b = 0.1
s = 0.04
t= 0
T = 1

for (j in 1:10){
  compare_mat[j,1] <- a
  compare_mat[j,2] <- b
  compare_mat[j,3] <- s
  compare_mat[j,4] <- 0.01 +0.01*(j-1)
  compare_mat[j,5] <- bond_price(alpha = compare_mat[j,1],beta = compare_mat[j,2], sigma = compare_mat[j,3], t= 0, T = 1, r = compare_mat[j,4])
  start_time <- proc.time()[1]
  compare_mat[j,6] <- monte_carlo(alpha = compare_mat[j,1],beta = compare_mat[j,2], sigma = compare_mat[j,3], t= 0, T = 1, r = compare_mat[j,4], n = 1000, s=250)
  compare_mat[j,7] <- proc.time()[1] -start_time
  compare_mat[j,8] <- (compare_mat[j,6] -compare_mat[j,5])^2
}

var <- sum(compare_mat[,8])/9

library(knitr)
kable(compare_mat,align = "c")
      
```

