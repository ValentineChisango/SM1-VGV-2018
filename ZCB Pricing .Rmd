---
title: "ZCB Pricing"
author:
- Valentine Chisango
- George Parekkadavil
- Vegan Pather
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls(all =TRUE))
```

```{r 1}
# Closed form solution to Bond price

bond_price <- function(alpha=0.08,beta=0.8,sigma=0.005,t=0,T=5,r=0.08){
  A <- (1-exp(-beta*(T-t)))/(beta)
  B <- (1/beta)*((alpha-(sigma)^2/(2*beta))*(A - T +t) - (sigma^(2)*A^2)/(4))
  exp(-A*r +B)
}

```

```{r 2}

# Crude Monte Carlo

Crude_Monte_Carlo=function(alpha =0.08,beta=0.8,sigma=0.005,T=5,r = 0.08,n=1000,s=100){
  
  # alpha, beta, sigma <- Fixed Parameters
  # T <- maturity time
  # r <- Initial rate at time 0
  # n <- Number of Simulations
  # s <- NUmber of Sub-intervals over time 
  
  #Simulate interest rates
  dt <- T/s # Length of sub-intervals
  sim_path = matrix(0,s+1,n) # Matrix that stores rate pathways
  sim_path[1,]= r # Initial rates on first row.
  
  for (i in 1:n){
    for (j in 2:(s+1)){
      dr=(alpha-beta*sim_path[j-1,i])*dt+sigma*sqrt(dt)*rnorm(1)# Discretize the SDE of the interest model using Euler Discretization to simulate rates over discrete sub-intervals
      sim_path[j,i]=sim_path[j-1,i]+dr
    }
  }
  
  # Monte Carlo Simulations
  Sum = colSums(sim_path[2:(s+1),]*dt) # Approximate the integral using summation
  int = exp(-Sum) # Take the exponent of the Integral
  mean = mean(int) # Find the average of expression
  mean
  
}

Crude_Monte_Carlo()
bond_price()
```

```{r 3}
# Improvements to the Monte Carlo Simulation

# Antithetic Variates

Antithetic_variates = function(alpha =0.08,beta=0.8,sigma=0.005,T=5,r = 0.08,n=1000,s=100){
  dt <- T/s # Length of sub-intervals
  sim_path= matrix(0,s+1,n) # Matrix that stores rate pathways
  sim_path_inv= matrix(0,nrow = s+1, ncol = n)# matrix to generate interest paths using negative values of RV
  sim_path[1,] = r
  sim_path_inv[1,] = r
  z = rnorm(n) # Generate standard normal values
  z. = -z # Negative RV
  
  for (i in 1:n){
    for (j in 2:(s+1)){
      dr=(alpha-beta*sim_path[j-1,i])*dt+sigma*sqrt(dt)*z[i] # Same Euler Discretization as in the Crude Monte Carlo function
      dr_i= (alpha-beta*sim_path_inv[j-1,i])*dt + sigma*sqrt(dt)*z.[i] # Euler Discretization for negative rates
      sim_path[j,i]=sim_path[j-1,i]+dr
      sim_path_inv[j,i]=sim_path_inv[j-1,i]+dr_i
      
    }
  }
  
  # Monte Carlo Simulations
  Sum=colSums(sim_path[2:(s+1),]*dt) # The Sum and Sum. variables record the summation of their respective rates to approximate the integral
  Sum.=colSums(sim_path_inv[2:(s+1),]*dt)
  int=exp(-Sum.) #Exponential of the estimate
  int.=exp(-Sum) #Exponential of the estimate under the negative rv 
  mean_1=mean(int) # Estimate using Z_i
  mean_2=mean(int.)  # Estimate using -Z_i
  result= (mean_1+mean_2)/2 # Final estimate
  result
  
}




```

```{r 4}
#################################################################################
# Moment matching
#################################################################################

Moment_Matching=function(alpha =0.08,beta=0.8,sigma=0.005,T=5,r0 = 0.08,n=1000,s=100){
  
  # alpha, beta, sigma <- Fixed Parameters
  # T <- maturity time
  # r0 <- Initial rate at time 0
  # n <- Number of Simulations
  # s <- NUmber of Subintervals 
  
  #Simulate interest rates
  dt <- T/s # Length of sub-intervals
  sim_path= matrix(0,s+1,n) # Matrix that stores rate pathways
  sim_path[1,]= r0
  z=rnorm(n)
  z_m= z-mean(z) # Moment matching transformation of RV to match finite moments 
  
  for (i in 1:n){
    for (j in 2:(s+1)){
      dr=(alpha-beta*sim_path[j-1,i])*dt+sigma*sqrt(dt)*z_m[i] # Simulate rates using the transformed rv 
      sim_path[j,i]=sim_path[j-1,i]+dr
    }
  }
  
  Sum=colSums(sim_path[2:(s+1),]*dt)
  int=exp(-Sum)
  result=mean(int)
  result

}




```

```{r 5}
#################################################################################
# Control Variates
#################################################################################

# We have decided to make use of the CIR model as our control variate process.
# Below is the closed form solution under the CIR model
bond_price_CIR <- function(alpha =0.08,beta=0.8,sigma=0.005,t=0,T=5,r = 0.08){
  h <- sqrt(beta^(2)+2*sigma^(2))
  A <-(2*h*exp((beta+h)*(T-t)/2)/(2*h+(beta+h)*(exp((T-t)*(h))-1)))^((2*alpha)/sigma^(2))
  B <-2*(exp((T-t)*(h))-1)/(2*h+(beta+h)*(exp((T-t)*(h))-1))
  A*exp(-B*r)
}


# Monte Carlo Simulations of Bond Price under the CIR model

CIR_MC= function(alpha =0.08,beta=0.8,sigma=0.005,T=5,r = 0.08,n=1000,s=100){
  
  dt <- T/s # Length of sub-intervals
  sim_path= matrix(0,s+1,n) # Matrix that stores rate pathways
  sim_path[1,]= r
  
  for (i in 1:n){
    for (j in 2:(s+1)){
      dr=(alpha-beta*sim_path[j-1,i])*dt+(sigma*sqrt(dt)*rnorm(1)*sqrt(sim_path[j-1,i]))# Euler Discretization
      sim_path[j,i]=sim_path[j-1,i]+dr
    
    }
  }
  
  # Monte Carlo Simulations
  Sum=colSums(sim_path[2:(s+1),]*dt)
  int=exp(-Sum)
  result=mean(int)
  result
  
}
# Therefore the control variates estimate:

Control_Variates_estimate= function(alpha =0.08,beta=0.8,sigma=0.005,t=0,T=5,r = 0.08,n=1000,s=100){
  Crude_Monte_Carlo(alpha,beta,sigma,T,r,n,s)[1]- CIR_MC(alpha,beta,sigma,T,r,n,s)[1]+bond_price_CIR(alpha,beta,sigma,t,T,r)
}


bond_price()
Control_Variates_estimate()
```

```{r}
# Comparisons of different methods
#################################################################################
# Stability of results
#################################################################################

# We do this by checking the variance amongst the results when simulated many times.

CR=NULL
AN=NULL
MM=NULL
CV=NULL

for ( i in 1:100){
  CR[i]=Crude_Monte_Carlo()
  #AN[i]=Antithetic_variates()
  #MM[i]=Moment_Matching()
  CV[i]=Control_Variates_estimate()
}


```


```{r 6}

#======================================================================================
# Doing some plots

xvec <- seq(-0.3,0.5,0.01)
S <- NULL
for (r in 1:length(xvec)){
  S[r] <- bond_price(0.08,0.8,0.005,0,5,xvec[r])
}

CR <- NULL
AV <- NULL
MM <- NULL
CO <- NULL

for (k in 1: length(xvec)){
  CR[k] <- Crude_Monte_Carlo(r0 = xvec[k], T=5)
}

for (s in 1: length(xvec)){
  AV[s] <- Antithetic_variates(r0 = xvec[s], T =5)
  
}

for (j in 1: length(xvec)){
  MM[j] <- Moment_Matching(r0 = xvec[j], T =5)
  
}

for (t in 1: length(xvec)){
  CO[t] <- Control_Variates_estimate(r0 = xvec[t], T =5)
  
}

plot(CR, x = xvec[1:length(xvec)],xlab = " Annual Interest Rate",ylab = "Bond Price",type = "l", col ="red", main = "Monte Carlo vs Known Solution")
lines(xvec,S, col ="blue", lty =1.5)
lines(xvec,AV, col ="black", lty =1.5)
lines(xvec,MM, col ="yellow", lty =1.5)
lines(xvec,MM, col ="green", lty =1.5)
```

```{r 7}
# Explicit Method


explicit = function(alpha= 0.08,beta=0.8,sigma=0.005,r=0.08,I=1:1250, J =seq(-0.4,0.6,0.005),T=5){
  
  # I = partition of time interval
  # J = partition of short rate interval
  
  M <- length(J)
  N <- length(I)
  
  dt <- T/N
  dr <- J[2] -J[1]
  
  pd <- function(j){
    ((J[j]+1/dt)^(-1))*(sigma^2/(2*(dr^2)) -(alpha -beta*J[j])/(2*dr))
  }
  
  
  pm <- function(j){
    ((J[j]+1/dt)^(-1))*(1/dt -sigma^2/(dr^2))
  }
  
  
  pu <- function(j){
    ((J[j]+1/dt)^(-1))*(sigma^2/(2*(dr^2)) + (alpha -beta*J[j])/(2*dr))
  }

  Diag_1 <- matrix(0,ncol = M, nrow = M)
    # Main diagonal of matrix 1
    
  for (j in 1:M){
    Diag_1[j,j] <- pm(j)
    
  }
  
  # Filling lower diagonal of matrix 1
  for (j in 2:M){
    Diag_1[j,j-1] <- pd(j)
  }
  
  # Filling upper diagonal of matirx 1
  for (j in 1:(M-1)){
    Diag_1[j,j+1] <- pu(j)
  }  
    
  Bond_values <- matrix(1,nrow=M, ncol =1)
  
  for (i in I){
    Bond_values <- Diag_1%*%Bond_values
    Bond_values <- Bond_values
  }
  
  index = match(as.character(r),xvec)
  Bond_values[index]
}


 



#============================================================================================
#Doing some plots
# 
#  xvec <- seq(-0.4,0.6,0.005)
# S <- NULL
# for (i in 1:length(xvec)){
#    S[i] <- bond_price(alpha = 0.08,beta =0.8,sigma =0.005,t = 0, T = 5, r = xvec[i])
#  }
#  
# H <- explicit(r = 0.08, I= 1:100000, T=5,alpha = 0.08, beta =0.8, sigma= 0.005, J = xvec)
# 
#  
#  plot(H, x = xvec,xlab = " Annual Interest Rate",ylab = "Bond Price",type = "l", col ="red", main = "Explicit vs Known Solution")
#  lines(xvec,S, col ="blue", lty =1.5)

```

```{r 8}

# Implicit Method

implicit <- function(alpha= 0.08,beta=0.8,sigma=0.005,r=0.08,I=1:1250, J =seq(-0.4,0.6,0.005),T=5){
  # I = partition of time interval
  # J = partition of short rate variable
  
  nr <- length(J) # number of rows based on rate grid points
  nc <- length(I) # number of columns based on number of time grid points
  
  dr <- J[2] - J[1] #length of each sub-interval across J
  dt <- T/length(I) #length of each sub-interval across I
  
  
  # For each j in J we define the following functions at a fixed time point
  
  pd <- function(j){
    dt*((alpha-beta*J[j+1])/(2*dr) - (sigma^2)/(2*dr^2))
    
  }
  
  pm <- function(j){
    dt*(J[j+1] + 1/dt +sigma^2/(dr^2))
  }
  
  pu <- function(j){
    -dt*((alpha-beta*J[j+1])/(2*dr) + (sigma^2)/(2*dr^2))
    
  }
  
  # Setting up tridiagonal matrix
  Diag <- matrix(0,nrow = nr-1,ncol = nr-1)
  
  # Filling main diagonal
  for (j in 1:(nr-1)){
    Diag[j,j] <- pm(j)
    
  }
  
  # Filling lower diagonal
  for (j in 2:(nr-1)){
    Diag[j,j-1] <- pd(j)
  }
  
  # Filling upper diagonal
  for (j in 1:(nr-2)){
    Diag[j,j+1] <- pu(j)
  }
  
  
  B <- matrix(1,ncol = 1,nrow = nr-1) # The matrix of bond prices at maturity time 
  
  for (i in I){
    C <- matrix(0,ncol = 1, nrow = nr-1) # Another matrix for boundary conditions
    C[nr-1,1] <- (-pu(nr-1))*B[nr-1,1]
    C[1,1] <- -pd(1)
    A <- B  # Working backwards recursively 
    B <- solve(Diag)%*%A 
  }
  
  #B # Output of bond prices at time 0 for varying rates
  index = match(as.character(r),xvec)
  B[index]
}


#============================================================================================

# Doing some plots

# xvec <- seq(-0.4,0.6,0.005)
# R <- implicit(T=5,J= xvec, I = 1:1250)
# S <- NULL
# for (r in 1:length(xvec)){
#   S[r] <- bond_price(0.08,0.8,0.005,0,5,xvec[r])
#   }
# plot(R, x = xvec[1:length(xvec)-1],xlab = " Annual Interest Rate",ylab = "Bond Price",type = "l", col ="red", main = "Implicit Method vs Known Solution")
# lines(xvec,S, col ="blue", lty =1.5)



```

```{r 9}
# Crank-Nicholson Method

CN <- function(alpha = 0.08, beta = 0.8, sigma = 0.005, r = 0.08, T =5 , I = 1:1250, J = seq(-0.4,0.8,0.005)){
  # I = partition of time interval
  # J = partition of short rate interval
  
  M <- length(J)
  N <- length(I)
  
  dt <- T/N
  dr <- J[2] -J[1]
  #===========================================================================================
  # Define the following functions for j = 1,...,M at each time point i
  
  
  pd <- function(j){
    (alpha -beta*J[j])/(4*dr) - sigma^2/(4*(dr^2))
  }
  
  pm <- function(j){
    sigma^2/(2*(dr^2)) + J[j]/2
  }
  
  pu <- function(j){
    -(alpha -beta*J[j])/(4*dr) - sigma^2/(4*(dr^2)) 
  
  }
  
  
  #===========================================================================================
  # Define 2 tridiagonal matricies. One for time point i and one for time point i+1
  
  Diag_1 <- matrix(0,nrow = M,ncol = M)
  Diag_2 <- matrix(0,nrow = M,ncol = M)
  
  # Main diagonal of matrix 1
  for (j in 1:M){
    Diag_1[j,j] <- -1/dt - pm(j)
    
  }
  
  # Filling lower diagonal of matrix 1
  for (j in 2:M){
    Diag_1[j,j-1] <- -pd(j)
  }
  
  # Filling upper diagonal of matirx 1
  for (j in 1:M-1){
    Diag_1[j,j+1] <- -pu(j)
  }  
  
  # Main diagonal of matrix 2
  for (j in 1:M){
    Diag_2[j,j] <- -1/dt + pm(j)
    
  }
  
  # Filling lower diagonal of matrix 2
  for (j in 2:M){
    Diag_2[j,j-1] <- pd(j)
  }
  
  # Filling upper diagonal of matirx 2
  for (j in 1:M-1){
    Diag_2[j,j+1] <- pu(j)
  }
  
  
  #===========================================================================================
  # Constructing more matricies and iterating the procedure from maturity to time 0

  Bond_values <- matrix(1,nrow = M, ncol = 1)
  
  # C_1 <- matrix(0,nrow = M,ncol = 1)
  # C_1[1,1] <- -2*pd(1)
  # C_1[M,1] <- -2*pu(M)
  # 
  # C_2 <- matrix(0,nrow = M,ncol = 1)
  # C_2[1,1] <- pd(1)
  # C_2[M,1] <- pu(M)
  Inv <- solve(Diag_1)
  

  
  for (i in I){
    
    RHS <- Diag_2%*%Bond_values 
    Bond_values <- Inv%*%RHS
  }

  #Bond_values
  
  index = match(as.character(r),xvec)
  Bond_values[index]
}




#============================================================================================
# Doing some plots

# xvec <- seq(-0.4,0.8,0.005)
# S <- NULL
# for (r in 1:length(xvec)){
#   S[r] <- bond_price(0.08,0.8,0.005,0,5,xvec[r])
# }
# plot(CN(), x = xvec[1:length(xvec)],xlab = " Annual Interest Rate",ylab = "Bond Price",type = "l", col ="red", main = "Crank - Nicolson vs Known Solution")
# lines(xvec,S, col ="blue", lty =1.5)
```

```{r 11}


```

```{r 12, echo = FALSE}
# Comparison of results
# Varying short rates

compare_mat <- matrix(NA,nrow = 10, ncol = 10) # matrix of comparison

colnames(compare_mat) <- c("Alpha","Beta","Sigma","Initial rate","Known Price","Monte Carlo"," MC System Time","MC Squared Deviations", "Moment Matching", "System Time")


for (j in 1:10){
  compare_mat[j,1] <- 0.08
  compare_mat[j,2] <- 0.8
  compare_mat[j,3] <- 0.005
  compare_mat[j,4] <- 0.01 +0.01*(j-1)
  compare_mat[j,5] <- bond_price(alpha = compare_mat[j,1],beta = compare_mat[j,2], sigma = compare_mat[j,3], t= 0, T = 1, r = compare_mat[j,4])
  start_time <- proc.time()[1]
  compare_mat[j,6] <- Crude_Monte_Carlo(alpha = compare_mat[j,1],beta = compare_mat[j,2], sigma = compare_mat[j,3], T = 1, r0 = compare_mat[j,4], n = 1000, s=250)
  compare_mat[j,7] <- proc.time()[1] -start_time
  compare_mat[j,8] <- (compare_mat[j,6] -compare_mat[j,5])^2
  start_time <- proc.time()[1]
  compare_mat[j,9] <- Moment_Matching(alpha = compare_mat[j,1],beta = compare_mat[j,2], sigma = compare_mat[j,3], T = 1, r0 = compare_mat[j,4], n = 1000, s=250)
  compare_mat[j,10] <- proc.time()[1] - start_time
  
}



# library(knitr)
# kable(compare_mat,align = "c")
       
```



```{r}
# Sensitivity Tests

senses <- matrix(nrow=13, ncol=9) # matrix to hold prices for various parameters
colnames(senses) <-c("Parameters","Closed Form","Crude Monte Carlo","Antithetic Variates","Moment Matching","Control Variates","Explicit","Implicit","Crank-Nicholson")

#Initial Parameters
senses[1,2]=bond_price()
senses[1,3]=Crude_Monte_Carlo()
senses[1,4]=Antithetic_variates()
senses[1,5]=Moment_Matching()
senses[1,6]=Control_Variates_estimate()
senses[1,7]=explicit()
senses[1,8]=implicit()
senses[1,9]=CN()

#r=0.05
senses[2,2]=bond_price(r=0.05)
senses[2,3]=Crude_Monte_Carlo(r=0.05)
senses[2,4]=Antithetic_variates(r=0.05)
senses[2,5]=Moment_Matching(r=0.05)
senses[2,6]=Control_Variates_estimate(r=0.05)
senses[2,7]=explicit(r=0.05)
senses[2,8]=implicit(r=0.05)
senses[2,9]=CN(r=0.05)

#r=0.1
senses[3,2]=bond_price(r=0.1)
senses[3,3]=Crude_Monte_Carlo(r=0.1)
senses[3,4]=Antithetic_variates(r=0.1)
senses[3,5]=Moment_Matching(r=0.1)
senses[3,6]=Control_Variates_estimate(r=0.1)
senses[3,7]=explicit(r=0.1)
senses[3,8]=implicit(r=0.1)
senses[3,9]=CN(r=0.1)

#T=1
senses[4,2]=bond_price(T=1)
senses[4,3]=Crude_Monte_Carlo(T=1)
senses[4,4]=Antithetic_variates(T=1)
senses[4,5]=Moment_Matching(T=1)
senses[4,6]=Control_Variates_estimate(T=1)
senses[4,7]=explicit(T=1)
senses[4,8]=implicit(T=1)
senses[4,9]=CN(T=1)

#T=10
senses[5,2]=bond_price(T=10)
senses[5,3]=Crude_Monte_Carlo(T=10)
senses[5,4]=Antithetic_variates(T=10)
senses[5,5]=Moment_Matching(T=10)
senses[5,6]=Control_Variates_estimate(T=10)
senses[5,7]=explicit(T=10)
senses[5,8]=implicit(T=10)
senses[5,9]=CN(T=10)

#sigma=0.001
senses[6,2]=bond_price(sigma=0.001)
senses[6,3]=Crude_Monte_Carlo(sigma=0.001)
senses[6,4]=Antithetic_variates(sigma=0.001)
senses[6,5]=Moment_Matching(sigma=0.001)
senses[6,6]=Control_Variates_estimate(sigma=0.001)
senses[6,7]=explicit(sigma=0.001)
senses[6,8]=implicit(sigma=0.001)
senses[6,9]=CN(sigma=0.001)


#sigma=0.01
senses[7,2]=bond_price(sigma=0.01)
senses[7,3]=Crude_Monte_Carlo(sigma=0.01)
senses[7,4]=Antithetic_variates(sigma=0.01)
senses[7,5]=Moment_Matching(sigma=0.01)
senses[7,6]=Control_Variates_estimate(sigma=0.01)
senses[7,7]=explicit(sigma=0.01)
senses[7,8]=implicit(sigma=0.01)
senses[7,9]=CN(sigma=0.01)


#alpha=0.01
senses[8,2]=bond_price(alpha=0.01)
senses[8,3]=Crude_Monte_Carlo(alpha=0.01)
senses[8,4]=Antithetic_variates(alpha=0.01)
senses[8,5]=Moment_Matching(alpha=0.01)
senses[8,6]=Control_Variates_estimate(alpha=0.01)
senses[8,7]=explicit(alpha=0.01)
senses[8,8]=implicit(alpha=0.01)
senses[8,9]=CN(alpha=0.01)

#alpha=0.016
senses[9,2]=bond_price(alpha=0.016)
senses[9,3]=Crude_Monte_Carlo(alpha=0.016)
senses[9,4]=Antithetic_variates(alpha=0.016)
senses[9,5]=Moment_Matching(alpha=0.016)
senses[9,6]=Control_Variates_estimate(alpha=0.016)
senses[9,7]=explicit(alpha=0.016)
senses[9,8]=implicit(alpha=0.016)
senses[9,9]=CN(alpha=0.016)

#beta=0.1
senses[10,2]=bond_price(beta=0.1)
senses[10,3]=Crude_Monte_Carlo(beta=0.1)
senses[10,4]=Antithetic_variates(beta=0.1)
senses[10,5]=Moment_Matching(beta=0.1)
senses[10,6]=Control_Variates_estimate(beta=0.1)
senses[10,7]=explicit(beta=0.1)
senses[10,8]=implicit(beta=0.1)
senses[10,9]=CN(beta=0.1)

#beta=0.16
senses[11,2]=bond_price(beta=0.16)
senses[11,3]=Crude_Monte_Carlo(beta=0.16)
senses[11,4]=Antithetic_variates(beta=0.16)
senses[11,5]=Moment_Matching(beta=0.16)
senses[11,6]=Control_Variates_estimate(beta=0.16)
senses[11,7]=explicit(beta=0.16)
senses[11,8]=implicit(beta=0.16)
senses[11,9]=CN(beta=0.16)

#alpha=0.01,beta=0.1
senses[12,2]=bond_price(alpha=0.01,beta=0.1)
senses[12,3]=Crude_Monte_Carlo(alpha=0.01,beta=0.1)
senses[12,4]=Antithetic_variates(alpha=0.01,beta=0.1)
senses[12,5]=Moment_Matching(alpha=0.01,beta=0.1)
senses[12,6]=Control_Variates_estimate(alpha=0.01,beta=0.1)
senses[12,7]=explicit(alpha=0.01,beta=0.1)
senses[12,8]=implicit(alpha=0.01,beta=0.1)
senses[12,9]=CN(alpha=0.01,beta=0.1)

#alpha=0.016,beta=0.16
senses[13,2]=bond_price(alpha=0.016,beta=0.16)
senses[13,3]=Crude_Monte_Carlo(alpha=0.016,beta=0.16)
senses[13,4]=Antithetic_variates(alpha=0.016,beta=0.16)
senses[13,5]=Moment_Matching(alpha=0.016,beta=0.16)
senses[13,6]=Control_Variates_estimate(alpha=0.016,beta=0.16)
senses[13,7]=explicit(alpha=0.016,beta=0.16)
senses[13,8]=implicit(alpha=0.016,beta=0.16)
senses[13,9]=CN(alpha=0.016,beta=0.16)

par(mfrow = c(2,2))
plot(1:8,senses[1,2:9])
lines(1:8,senses[2, 2:9], col="red", type="l")

```


```{r}
#Stability
stables <- matrix(nrow=4, ncol=100) # matrix to hold prices for various parameters

for (i in 1:100){
  stables[1,i] <- Crude_Monte_Carlo()
  stables[2,i] <- Antithetic_variates()
}

for (i in 1:100){
  stables[3,i] <- Moment_Matching()
  stables[4,i] <- Control_Variates_estimate()
}

plot(1:100, stables[1,], type="l", col="blue")
lines(x=1:100, y=stables[2,], col="red")

```

