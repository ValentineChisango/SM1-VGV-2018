---
title: "ZCB Pricing"
author:
- Valentine Chisango
- George Parekkadavil
- Vegan Pather
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list = ls(all =TRUE))
```

```{r 1}
# Closed form solution to Bond price

bond_price <- function(alpha=0.08,beta=0.8,sigma=0.005,t=0,T=1,r=0.08){
  A <- (1-exp(-beta*(T-t)))/(beta)
  B <- (1/beta)*((alpha-(sigma)^2/(2*beta))*(A - T +t) - (sigma^(2)*A^2)/(4))
  exp(-A*r +B)
}

```

```{r 2}
# Monte Carlo Simulation

monte_carlo <- function(alpha =0.08, beta=0.8, sigma=0.005, t=0, T=1, r=0.08, n=1000, s=100){
  # s = number of sub-intervals
  # n = number of simulation trials  
  
  dt <- T/s
  sim_path <- matrix(NA,nrow = n, ncol = 1) # matrix to store simulated path integrals
  sim_r <- NULL # vector to store rates on the path
  
  
  for (d in 1:n){
    sim_r[1] <- r
    for (j in 2:s){
      mu <- alpha/beta + exp(-beta*dt)*(sim_r[j-1] -alpha/beta)
      sd <- sqrt((sigma^2/(2*beta))*(1 -exp(-2*beta*(dt))))
      sim_r[j] <- rnorm(1,mu,sd)
    }
    
    int <- dt*(sum(sim_r)) # integral of path
    sim_path[d,1] <- exp(-int) # bond price of path
    
  }
  mean(sim_path) # empirical expectation of bond price using all paths
}

```

```{r}

# Another Version of the MOnte Carlo simulations
Crude_Monte_Carlo=function(alpha =0.08,beta=0.8,sigma=0.005,T=1,r0 = 0.08,n=1000,s=100){
  
  # alpha, beta, sigma <- Fixed Parameters
  # T <- maturity time
  # r0 <- Initial rate at time 0
  # n <- Number of Simulations
  # s <- NUmber of Subintervals 
  
  #Simulate interest rates
  dt <- T/s # Length of sub-intervals
  sim_path= matrix(0,s+1,n) # Matrix that stores rate pathways
  sim_path[1,]= r0
  
  for (i in 1:n){
    for (j in 2:(s+1)){
      dr=(alpha-beta*sim_path[j-1,i])*dt+sigma*sqrt(dt)*rnorm(1)# Euler Discretization
      sim_path[j,i]=sim_path[j-1,i]+dr
    }
  }
  
  # Monte Carlo Simulations
  Sum=colSums(sim_path[2:(s+1),]*dt)
  int=exp(-Sum)
  mean=mean(int)
  sd=sd(int)/sqrt(n)
  result=mean
  result
}


```




```{r 3}
# Improvements to the Monte Carlo Simulation


#################################################################################
# Antithetic Variates
################################################################################

Antithetic_variates= function(alpha =0.08,beta=0.8,sigma=0.005,T=1,r0 = 0.08,n=1000,s=100){
  dt <- T/s # Length of sub-intervals
  sim_path= matrix(0,s+1,n) # Matrix that stores rate pathways
  sim_path_inv= matrix(0,nrow = s+1, ncol = n)# matrix to generate interest paths using inverse RV
  sim_path[1,]= r0
  sim_path_inv[1,]=r0
  z = rnorm(n)
  z. = -z
  
  for (i in 1:n){
    for (j in 2:(s+1)){
      dr=(alpha-beta*sim_path[j-1,i])*dt+sigma*sqrt(dt)*z[i] # Euler Discretization
      dr_i= (alpha-beta*sim_path_inv[j-1,i])*dt + sigma*sqrt(dt)*z.[i]
      sim_path[j,i]=sim_path[j-1,i]+dr
      sim_path_inv[j,i]=sim_path_inv[j-1,i]+dr_i
      
    }
  }
  
  # Monte Carlo Simulations
  Sum=colSums(sim_path[2:(s+1),]*dt)
  Sum.=colSums(sim_path_inv[2:(s+1),]*dt)
  int.=exp(-Sum.)
  int=exp(-Sum)# Estimate using the conjugate rates
  Average=(int+int.)/2 # Average of estimates
  mean=mean(Average)
  sd=sd(Average)/sqrt(n)
  result= mean
  result
  
}



```


```{r}
#################################################################################
# Moment matching
#################################################################################

Moment_Matching=function(alpha =0.08,beta=0.8,sigma=0.005,T=1,r0 = 0.08,n=1000,s=100){
  
  # alpha, beta, sigma <- Fixed Parameters
  # T <- maturity time
  # r0 <- Initial rate at time 0
  # n <- Number of Simulations
  # s <- NUmber of Subintervals 
  
  #Simulate interest rates
  dt <- T/s # Length of sub-intervals
  sim_path= matrix(0,s+1,n) # Matrix that stores rate pathways
  sim_path[1,]= r0
  z=rnorm(n)
  z_m= z-mean(z) # MOMENT MATCHING TRANSFORMATION 
  
  for (i in 1:n){
    for (j in 2:(s+1)){
      dr=(alpha-beta*sim_path[j-1,i])*dt+sigma*sqrt(dt)*z_m[i]# Euler Discretization
      sim_path[j,i]=sim_path[j-1,i]+dr
    }
  }
  
  # Monte Carlo Simulations
  Sum=colSums(sim_path[2:(s+1),]*dt)
  int=exp(-Sum)
  mean=mean(int)
  sd=sd(int)/sqrt(n)
  result=mean
  result
}

```

```{r}
#################################################################################
# Control Variates
#################################################################################

# We have decided to make use of the CIR model as our control variate process.
# Below is the closed form solution under the CIR model
bond_price_CIR <- function(alpha,beta,sigma,t,T,r0){
  h <- sqrt(alpha^(2)+2*sigma^(2))
  A <-(2*h*exp((alpha+h)*(T-t)/2)/(2*h+(alpha+h)*(exp((T-t)*(h))-1)))^((2*alpha*beta)/sigma^(2))
  B <-2*(exp((T-t)*(h))-1)/(2*h+(alpha+h)*(exp((T-t)*(h))-1))
  A*exp(-B*r0)
}


# Monte Carlo Simulations of Bond Price under the CIR model

CIR_MC= function(alpha,beta,sigma,T,r0,n,s){
  
  dt <- T/s # Length of sub-intervals
  sim_path= matrix(0,s+1,n) # Matrix that stores rate pathways
  sim_path[1,]= r0
  
  for (i in 1:n){
    for (j in 2:(s+1)){
      dr=alpha*(beta-sim_path[j-1,i])*dt+(sigma*sqrt(dt)*rnorm(1)*sqrt(sim_path[j-1,i]))# Euler Discretization
      sim_path[j,i]=sim_path[j-1,i]+dr
    
    }
  }
  
  # Monte Carlo Simulations
  Sum=colSums(sim_path[2:(s+1),]*dt)
  int=exp(-Sum)
  mean=mean(int)
  sd=sd(int)/sqrt(n)
  result=c(mean,sd)
  result
  
}

# Therefore the control variates estimate:

Control_Variates_estimate= function(alpha, beta, sigma,t,T,r0,n,s){
  Crude_Monte_Carlo(alpha,beta,sigma,T,r0,n,s)[1]- CIR_MC(alpha,beta,sigma,T,r0,n,s)[1]+bond_price_CIR(alpha,beta,sigma,t,T,r0)
}
  

```


```{r}

#============================================================================================
# Doing some plots

xvec <- seq(-0.3,0.5,0.01)
S <- NULL
for (r in 1:length(xvec)){
  S[r] <- bond_price(0.08,0.8,0.005,0,5,xvec[r])
}

CR <- NULL
AV <- NULL
MM <- NULL

for (k in 1: length(xvec)){
  CR[k] <- Crude_Monte_Carlo(r0 = xvec[k], T=5)
}

for (s in 1: length(xvec)){
  AV[s] <- Antithetic_variates(r0 = xvec[s], T =5)
  
}

for (j in 1: length(xvec)){
  MM[j] <- Moment_Matching(r0 = xvec[j], T =5)
  
}

plot(CR, x = xvec[1:length(xvec)],xlab = " Annual Interest Rate",ylab = "Bond Price",type = "l", col ="red", main = "Monte Carlo vs Known Solution")
lines(xvec,S, col ="blue", lty =1.5)
lines(xvec,AV, col ="black", lty =1.5)
lines(xvec,MM, col ="yellow", lty =1.5)
```



```{r 4}
# Explicit Method

# Simple Bond price function
B <- function(t,T,r){
  exp(-(T-t)*r)
}

explicit <- function(alpha= 0.08,beta=0.8,sigma=0.005,r=0.08,I=1:100,T=2){

# I = partition of time
# J = partition of rate
# dr = length of rate sub-intervals
# r must be in the middle of partition of J
# length of J must be twice the length of I
dr <- 2*r/(2*length(I))
  
J <- seq(0,2*r,dr)    

dt = T/length(I) # length of each time sub-interval

V <- matrix(NA, nrow = length(J), ncol = length(I)+1) # empty matrix
nr <- length(J) # number of rows of the matrix - represents partition of rate
nt <- length(I)+1 # number of columns - represents partition of time

V[,length(I)+1] <- rep(1) # Boundary condition at expiry of bond

count <- 0 # set up count variable
for (i in rev(I)){ # rev is the reverse order of the time partition | i corresponds to the columns of the lattice
  count <- count+1 # keeping track of loop
  for (j in (1+count):(nr-count)){ # j corresponds to the rows of the lattice
    pu <- dt*(sigma^2/(2*dr^2) + (alpha -beta*J[nr-j])/(2*dr)) # up value
    pm <- 1 - (sigma^2*dt)/(dr^2) # middle value
    pd <- dt*(sigma^2/(2*(dr^2)) - (alpha -beta*J[nr-j])/(2*dr)) # down value
    V[j,i] <- ((1+J[nr-j]*dt)^(-1))*(pu*V[j-1,i+1] + pm*V[j,i+1] +pd*V[j+1,i+1])
  }

}

V[(nr+1)/2,1]

}


#============================================================================================
#Doing some plots
# 
# xvec <- seq(-0.3,0.5,0.01)
# H <- NULL
# for (r in 1:length(xvec)){
#   S[r] <- bond_price(0.08,0.8,0.005,0,1,xvec[r])
# }
# 
# for (i in 1:length(xvec)){
#   H[i] <- explicit(r = xvec[i], I= 1:50, T=5)
# }
# 
# plot(H, x = xvec,xlab = " Annual Interest Rate",ylab = "Bond Price",type = "l", col ="red", main = "Crank - Nicolson vs Known Solution")
# lines(xvec,S, col ="blue", lty =1.5)

```

```{r 5}

# Implicit Method

implicit <- function(alpha= 0.08,beta=0.8,sigma=0.005,r=0.08,I=1:100, J =seq(0,0.10,0.01),T=1){
  # I = partition of time interval
  # J = partition of short rate variable
  
  nr <- length(J) # number of rows based on rate grid points
  nc <- length(I) # number of columns based on number of time grid points
  
  dr <- J[2] - J[1] #length of each sub-interval across J
  dt <- T/length(I) #length of each sub-interval across I
  
  
  # For each j in J we define the following functions at a fixed time point
  
  pd <- function(j){
    dt*((alpha-beta*J[j+1])/(2*dr) - (sigma^2)/(2*dr^2))
    
  }
  
  pm <- function(j){
    dt*(J[j+1] + 1/dt +sigma^2/(dr^2))
  }
  
  pu <- function(j){
    -dt*((alpha-beta*J[j+1])/(2*dr) + (sigma^2)/(2*dr^2))
    
  }
  
  # Setting up tridiagonal matrix
  Diag <- matrix(0,nrow = nr-1,ncol = nr-1)
  
  # Filling main diagonal
  for (j in 1:(nr-1)){
    Diag[j,j] <- pm(j)
    
  }
  
  # Filling lower diagonal
  for (j in 2:(nr-1)){
    Diag[j,j-1] <- pd(j)
  }
  
  # Filling upper diagonal
  for (j in 1:(nr-2)){
    Diag[j,j+1] <- pu(j)
  }
  
  
  B <- matrix(1,ncol = 1,nrow = nr-1) # The matrix of bond prices at maturity time 
  
  for (i in I){
    C <- matrix(0,ncol = 1, nrow = nr-1) # Another matrix for boundary conditions
    C[nr-1,1] <- (-pu(nr-1))*B[nr-1,1]
    C[1,1] <- -pd(1)
    A <- B + C # Working backwards recursively 
    B <- solve(Diag)%*%A 
  }
  
  B # Output of bond prices at time 0 for varying rates
  
}


#============================================================================================

# Doing some plots

xvec <- seq(-0.3,0.6,0.01)
R <- implicit(T=5,J= xvec, I = 1:1250)
S <- NULL
for (r in 1:length(xvec)){
  S[r] <- bond_price(0.08,0.8,0.005,0,5,xvec[r])
  }
plot(R, x = xvec[1:length(xvec)-1],xlab = " Annual Interest Rate",ylab = "Bond Price",type = "l", col ="red", main = "Implicit Method vs Known Solution")
lines(xvec,S, col ="blue", lty =1.5)



```

```{r 6}
# Crank-Nicholson Method

CN <- function(alpha, beta, sigma, r,T, I, J){
  # I = partition of time interval
  # J = partition of short rate interval
  
  X <- length(I) # number of time grid points
  Y <- length(J) # number of rate grid points
  
  nr <- Y - 1 # number of rows
  
  dr <- J[2] - J[1]
  dt <- T/X
  
  #===========================================================================================
  # Define the following functions for j = 1,...,nr at each time point i
  
  pd <- function(j){
    (alpha -beta*J[j+1])/(2*dr) - sigma^2/(4*dr^2)
  }
  
  pm_1 <- function(j){
    J[j+1]/2 + 1/dt + sigma^2/(2*dr^2)
  }
  
  pm_2 <- function(j){
    -J[j+1]/2 + 1/dt - sigma^2/(2*dr^2)
  }
  
  pu <- function(j){
    - (alpha -beta*J[j+1])/(2*dr) - sigma^2/(4*dr^2)
  }
  
  #===========================================================================================
  # Define 2 tridiagonal matricies. One for time point i and one for time point i+1
  
  Diag_1 <- matrix(0,nrow = nr,ncol = nr)
  Diag_2 <- matrix(0,nrow = nr,ncol = nr)
  
  # Main diagonal of matrix 1
  for (j in 1:nr){
    Diag_1[j,j] <- pm_1(j)
    
  }
  
  # Filling lower diagonal of matrix 1
  for (j in 2:nr){
    Diag_1[j,j-1] <- pd(j)
  }
  
  # Filling upper diagonal of matirx 1
  for (j in 1:(nr-1)){
    Diag_1[j,j+1] <- pu(j)
  }  
  
  # Main diagonal of matrix 2
  for (j in 1:nr){
    Diag_2[j,j] <- pm_2(j)
    
  }
  
  # Filling lower diagonal of matrix 2
  for (j in 2:nr){
    Diag_2[j,j-1] <- -pd(j)
  }
  
  # Filling upper diagonal of matirx 2
  for (j in 1:(nr-1)){
    Diag_2[j,j+1] <- -pu(j)
  }
  
  
  #===========================================================================================
  # Constructing more matricies and iterating the procedure from maturity to time 0
  # These matricies take care of the boundary conditions
  C_1 <- matrix(0,nrow = nr,ncol = 1)
  C_1[1,1] <- pd(1)
  C_1[nr,1] <- pu(nr)
  
  C_2 <- matrix(0,nrow = nr,ncol = 1)
  C_2[1,1] <- -pd(1)
  C_2[nr,1] <- -pu(nr)
  
  # Vector of bond price values at time i
  Bond_values <- matrix(1,nrow = nr, ncol = 1)
  
  for (i in I){
    Inv <- solve(Diag_1)
    RHS <- Diag_2%*%Bond_values + C_2 - C_1
    Bond_values <- Inv%*%RHS
  }

  Bond_values
  
}


G <- CN(0.08,0.8,0.005,0.05, T=5, I=1:365, J = seq(-0.3,0.5,0.01))

#============================================================================================
# Doing some plots

xvec <- seq(-0.3,0.5,0.01)
S <- NULL
for (r in 1:length(xvec)){
  S[r] <- bond_price(0.08,0.8,0.005,0,1,xvec[r])
}
plot(G, x = xvec[1:length(xvec)-1],xlab = " Annual Interest Rate",ylab = "Bond Price",type = "l", col ="red", main = "Crank - Nicolson vs Known Solution")
lines(xvec,S, col ="blue", lty =1.5)
```

```{r}
# Crank Nicolson 2.0

CN_2 <- function(alpha = 0.08,beta =0.8,sigma=0.005,T=5,r =0.05,I = 1:1250, J = seq(-0.3,0.5,0.01)){
  
  M <- length(J)
  
  
  
  
  
}




```




```{r 7}
# Modified Fully Implicit Method
```

```{r 8, echo = FALSE}
# Comparison of results
# Varying short rates

compare_mat <- matrix(NA,nrow = 10, ncol = 8) # matrix of comparison

colnames(compare_mat) <- c("Alpha","Beta","Sigma","Initial rate","Known Price","Monte Carlo"," MC System Time","MC Squared Deviations")


a = 0.01
b = 0.1
s = 0.04
t= 0
T = 1

for (j in 1:10){
  compare_mat[j,1] <- a
  compare_mat[j,2] <- b
  compare_mat[j,3] <- s
  compare_mat[j,4] <- 0.01 +0.01*(j-1)
  compare_mat[j,5] <- bond_price(alpha = compare_mat[j,1],beta = compare_mat[j,2], sigma = compare_mat[j,3], t= 0, T = 1, r = compare_mat[j,4])
  start_time <- proc.time()[1]
  compare_mat[j,6] <- monte_carlo(alpha = compare_mat[j,1],beta = compare_mat[j,2], sigma = compare_mat[j,3], t= 0, T = 1, r = compare_mat[j,4], n = 1000, s=250)
  compare_mat[j,7] <- proc.time()[1] -start_time
  compare_mat[j,8] <- (compare_mat[j,6] -compare_mat[j,5])^2
}

var <- sum(compare_mat[,8])/9

library(knitr)
kable(compare_mat,align = "c")
      
```

